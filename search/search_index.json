{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to VidarDB VidarDB is the world's first unified database system that can replace multiple data systems with a single unified tool. It is open-source, and actively developed and maintained by VidarDB team.","title":"Welcome to VidarDB"},{"location":"#welcome-to-vidardb","text":"VidarDB is the world's first unified database system that can replace multiple data systems with a single unified tool. It is open-source, and actively developed and maintained by VidarDB team.","title":"Welcome to VidarDB"},{"location":"example/","text":"VidarDB Examples In this section, we are going to show some basic VidarDB commands and simple interactions with PostgreSQL. Basic Commands To create a database example and switch to it: CREATE DATABASE example; \\c example; Create a new table student using VidarDB's data engine. Claiming EXTENSION and SERVER are needed to trigger VidarDB's engine: CREATE EXTENSION kv_fdw; CREATE SERVER kv_server FOREIGN DATA WRAPPER kv_fdw; CREATE FOREIGN TABLE student(name TEXT, ID TEXT) SERVER kv_server; Let's try to insert some sample data into our new table: INSERT INTO student VALUES('Rafferty', '20757123'); INSERT INTO student VALUES('Jones', '20767234'); INSERT INTO student VALUES('Heisenberg', '20777345'); In the next step, use SELECT statement to query students' information: example=# SELECT * FROM student; name | id ------------+---------- Jones | 20767234 Rafferty | 20757123 Heisenberg | 20777345 (3 rows) Also have a try at DELETE statement: example=# DELETE FROM student WHERE name='Jones'; DELETE 1 example=# SELECT * FROM student; name | id ------------+---------- Rafferty | 20757123 Heisenberg | 20777345 (2 rows) And update Rafferty's student id to 20757321 : example=# UPDATE student SET ID='20757321' WHERE name='Rafferty'; UPDATE 1 example=# SELECT * FROM student; name | id ------------+---------- Rafferty | 20757321 Heisenberg | 20777345 (2 rows) Interaction with PostgreSQL VidarDB works seamlessily with the original PostgreSQL. Now, we will create another new table using PostgreSQL's storage engine and add one row into it: CREATE TABLE student_course(ID TEXT, course TEXT); INSERT INTO student_course VALUES('20757321', 'Computer Science'); We currently have something like: example=# SELECT * FROM student_course; id | course ----------+------------------ 20757321 | Computer Science (1 row) Let's try with the JOIN statement with the table student (created by VidarDB engine) and student_course (created by PostgreSQL engine): example=# SELECT student.name FROM student, student_course WHERE student.id = student_course.id; name ---------- Rafferty (1 row) (More examples will come soon!)","title":"VidarDB Examples"},{"location":"example/#vidardb-examples","text":"In this section, we are going to show some basic VidarDB commands and simple interactions with PostgreSQL.","title":"VidarDB Examples"},{"location":"example/#basic-commands","text":"To create a database example and switch to it: CREATE DATABASE example; \\c example; Create a new table student using VidarDB's data engine. Claiming EXTENSION and SERVER are needed to trigger VidarDB's engine: CREATE EXTENSION kv_fdw; CREATE SERVER kv_server FOREIGN DATA WRAPPER kv_fdw; CREATE FOREIGN TABLE student(name TEXT, ID TEXT) SERVER kv_server; Let's try to insert some sample data into our new table: INSERT INTO student VALUES('Rafferty', '20757123'); INSERT INTO student VALUES('Jones', '20767234'); INSERT INTO student VALUES('Heisenberg', '20777345'); In the next step, use SELECT statement to query students' information: example=# SELECT * FROM student; name | id ------------+---------- Jones | 20767234 Rafferty | 20757123 Heisenberg | 20777345 (3 rows) Also have a try at DELETE statement: example=# DELETE FROM student WHERE name='Jones'; DELETE 1 example=# SELECT * FROM student; name | id ------------+---------- Rafferty | 20757123 Heisenberg | 20777345 (2 rows) And update Rafferty's student id to 20757321 : example=# UPDATE student SET ID='20757321' WHERE name='Rafferty'; UPDATE 1 example=# SELECT * FROM student; name | id ------------+---------- Rafferty | 20757321 Heisenberg | 20777345 (2 rows)","title":"Basic Commands"},{"location":"example/#interaction-with-postgresql","text":"VidarDB works seamlessily with the original PostgreSQL. Now, we will create another new table using PostgreSQL's storage engine and add one row into it: CREATE TABLE student_course(ID TEXT, course TEXT); INSERT INTO student_course VALUES('20757321', 'Computer Science'); We currently have something like: example=# SELECT * FROM student_course; id | course ----------+------------------ 20757321 | Computer Science (1 row) Let's try with the JOIN statement with the table student (created by VidarDB engine) and student_course (created by PostgreSQL engine): example=# SELECT student.name FROM student, student_course WHERE student.id = student_course.id; name ---------- Rafferty (1 row) (More examples will come soon!)","title":"Interaction with PostgreSQL"},{"location":"faq/","text":"Frequently Asked Questions How is VidarDB different from other database systems? There are several fundamental differences. First, unlike most database systems relying on the data structure designed in the 1970s, VidarDB employs a new data structure designed for modern memory architecture, efficiently supporting RAM, NVM, SSD, Disk as well as smooth data flow among these storage tiers. Additionally, it is a versatile data structure, which will adapt to and optimize for different workloads, such as operational, data analysis, streaming and even mixed of them. Then, we have brought the machine learning ability into VidarDB, where users can run familiar machine learning algorithms inside VidarDB via SQL, without moving your data to other tools. What is the relationship between VidarDB and PostgreSQL? VidarDB utilizes the frontend of PostgreSQL, including its parser and optimizer, but replaces storage engine of PostgreSQL with a novel database engine based on a revolutionary data structure. Currently, we keep both storage engines coexisted. Thus, you can join two tables created from different engines. Once VidarDB\u2019s storage engine is mature, we will remove the engine of PostgreSQL. Meanwhile, VidarDB embraces the PostgreSQL ecosystem, meaning all the client drivers, tools and other components of PostgreSQL can be utilized in VidarDB directly without changing the code. Is VidarDB stable enough to use? The idea and design of VidarDB are groundbreaking, but we do not develop VidarDB from scratch. Instead, the storage engine of VidarDB is built on a mature key-value store, RocksDB, where VidarDB seamlessly infuses the design and idea into the core data structure of RocksDB, and keeps the quality of code. Additionally, VidarDB effectively utilizes the frontend of PostgreSQL, a popular database system, resulting in a familiar interface to users. What are the system requirements for VidarDB? VidarDB is written in C++, and natively runs on Linux systems. Other operating systems are being tested. We also provide a docker image for users to quickly deploy VidarDB on any platform. What client driver can I use to work with VidarDB? VidarDB reuses the frontend of PostgreSQL, so the client drivers for PostgreSQL can also work with VidarDB without code change. Languages such as Java, C++, Python, Go and C#/.Net are all supported. Does VidarDB support SQL? Yes, VidarDB supports the SQL syntax in PostgreSQL. Users can even call AI algorithms with SQL. How is VidarDB licensed? VidarDB is licensed under the modified BSD 3-Clause Clear License. Anyone, no matter person or enterprise, can use it for free. But selling it directly as a service in the cloud is prohibited.","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#how-is-vidardb-different-from-other-database-systems","text":"There are several fundamental differences. First, unlike most database systems relying on the data structure designed in the 1970s, VidarDB employs a new data structure designed for modern memory architecture, efficiently supporting RAM, NVM, SSD, Disk as well as smooth data flow among these storage tiers. Additionally, it is a versatile data structure, which will adapt to and optimize for different workloads, such as operational, data analysis, streaming and even mixed of them. Then, we have brought the machine learning ability into VidarDB, where users can run familiar machine learning algorithms inside VidarDB via SQL, without moving your data to other tools.","title":"How is VidarDB different from other database systems?"},{"location":"faq/#what-is-the-relationship-between-vidardb-and-postgresql","text":"VidarDB utilizes the frontend of PostgreSQL, including its parser and optimizer, but replaces storage engine of PostgreSQL with a novel database engine based on a revolutionary data structure. Currently, we keep both storage engines coexisted. Thus, you can join two tables created from different engines. Once VidarDB\u2019s storage engine is mature, we will remove the engine of PostgreSQL. Meanwhile, VidarDB embraces the PostgreSQL ecosystem, meaning all the client drivers, tools and other components of PostgreSQL can be utilized in VidarDB directly without changing the code.","title":"What is the relationship between VidarDB and PostgreSQL?"},{"location":"faq/#is-vidardb-stable-enough-to-use","text":"The idea and design of VidarDB are groundbreaking, but we do not develop VidarDB from scratch. Instead, the storage engine of VidarDB is built on a mature key-value store, RocksDB, where VidarDB seamlessly infuses the design and idea into the core data structure of RocksDB, and keeps the quality of code. Additionally, VidarDB effectively utilizes the frontend of PostgreSQL, a popular database system, resulting in a familiar interface to users.","title":"Is VidarDB stable enough to use?"},{"location":"faq/#what-are-the-system-requirements-for-vidardb","text":"VidarDB is written in C++, and natively runs on Linux systems. Other operating systems are being tested. We also provide a docker image for users to quickly deploy VidarDB on any platform.","title":"What are the system requirements for VidarDB?"},{"location":"faq/#what-client-driver-can-i-use-to-work-with-vidardb","text":"VidarDB reuses the frontend of PostgreSQL, so the client drivers for PostgreSQL can also work with VidarDB without code change. Languages such as Java, C++, Python, Go and C#/.Net are all supported.","title":"What client driver can I use to work with VidarDB?"},{"location":"faq/#does-vidardb-support-sql","text":"Yes, VidarDB supports the SQL syntax in PostgreSQL. Users can even call AI algorithms with SQL.","title":"Does VidarDB support SQL?"},{"location":"faq/#how-is-vidardb-licensed","text":"VidarDB is licensed under the modified BSD 3-Clause Clear License. Anyone, no matter person or enterprise, can use it for free. But selling it directly as a service in the cloud is prohibited.","title":"How is VidarDB licensed?"},{"location":"run_kmeans_with_vidarDB/","text":"Run KMeans with VidarDB VidarDB natively supports AI, which is built on MADlib allowing you to perfrom various commonly-used AI algorithms in SQL easily. This page gives you a good example of using KMeans clustering algorithm to train data in VidarDB. It assumes VidarDB is already installed. If not, please head over to the Run VidarDB with Docker section. Preparation Make sure psql is installed on your computer. If not, for Debian users: sudo apt-get install postgresql-client Clone and go into the VidarDB's util repository: git clone https://github.com/vidardb/util.git && cd util Import Chicago Taxi Trips data: cd ./util-notebook/kmeans/ && psql -h 127.0.0.1 -p 5432 -U postgres -f ./import-data_chicago_taxi_trips.sql This will also create a new database called chicago_taxi_trips . Then, create a new table chicago_taxi_trips_change for the data training: -- connect to the local vidardb psql -h 127.0.0.1 -p 5432 -U postgres -- connect to the database \\c chicago_taxi_trips postgres; -- create new table DROP TABLE IF EXISTS chicago_taxi_trips_change; -- double precision array for (pickup_latitude,pickup_longitude) CREATE TABLE chicago_taxi_trips_change ( row_id SERIAL, taxi_id INT, pickup_latitude DECIMAL(10, 2), pickup_longitude DECIMAL(10, 2), row_vec DOUBLE PRECISION[] ); -- insert data INSERT INTO chicago_taxi_trips_change (taxi_id,pickup_latitude,pickup_longitude, row_vec) SELECT taxi_id, pickup_latitude, pickup_longitude, array_cat(array[pickup_latitude], array[pickup_longitude]) FROM chicago_taxi_trips; Now, the preparation is done. Let's move to the training part. Data Training This section is very simple and straightforward. Before training data, we need to enable AI support in chicago_taxi_trips database: docker exec -it vidardb sh -c \"install-madlib.sh -U postgres -D chicago_taxi_trips\" Try the following SQL commands to train data with KMeans: -- connect to the local vidardb psql -h 127.0.0.1 -p 5432 -U postgres -- connect to the database \\c chicago_taxi_trips postgres; -- create new table DROP TABLE IF EXISTS km_result; -- run kmeans algorithm CREATE TABLE km_result AS SELECT * FROM madlib.kmeanspp( 'chicago_taxi_trips_change', -- Table of source data 'row_vec', -- Column containing point co-ordinates 5, -- Number of centroids to calculate 'madlib.squared_dist_norm2', -- Distance function 'madlib.avg', -- Aggregate function 20, -- Number of iterations 0.001 -- Fraction of centroids reassigned to keep iterating ); Perform Clustering Predictions Predict the cluster_id of each trip with the model we have just trained: SELECT trips_data.*, (madlib.closest_column(centroids, row_vec)).column_id AS cluster_id FROM chicago_taxi_trips_change AS trips_data, km_result ORDER BY trips_data.row_id DESC LIMIT 10; We can get some results like this: row_id | taxi_id | pickup_latitude | pickup_longitude | row_vec | cluster_id --------+---------+-----------------+------------------+------------------------------+------------ 999 | 7040 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 998 | 7145 | 41.88 | -87.64 | {41.879255084,-87.642648998} | 1 997 | 7864 | 41.79 | -87.75 | {41.785998518,-87.750934289} | 3 996 | 6620 | 41.90 | -87.62 | {41.89503345,-87.619710672} | 0 995 | 393 | 41.89 | -87.63 | {41.892072635,-87.628874157} | 0 994 | 1082 | 41.89 | -87.62 | {41.890922026,-87.618868355} | 0 993 | 55 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 992 | 7749 | 41.89 | -87.63 | {41.892042136,-87.63186395} | 0 991 | 7564 | 41.88 | -87.62 | {41.884987192,-87.620992913} | 0 990 | 7065 | 41.89 | -87.63 | {41.892507781,-87.626214906} | 0 Reference The data this example used come from Taxi Trips | City of Chicago | Data Portal . (More examples will come soon!)","title":"Run KMeans with VidarDB"},{"location":"run_kmeans_with_vidarDB/#run-kmeans-with-vidardb","text":"VidarDB natively supports AI, which is built on MADlib allowing you to perfrom various commonly-used AI algorithms in SQL easily. This page gives you a good example of using KMeans clustering algorithm to train data in VidarDB. It assumes VidarDB is already installed. If not, please head over to the Run VidarDB with Docker section.","title":"Run KMeans with VidarDB"},{"location":"run_kmeans_with_vidarDB/#preparation","text":"Make sure psql is installed on your computer. If not, for Debian users: sudo apt-get install postgresql-client Clone and go into the VidarDB's util repository: git clone https://github.com/vidardb/util.git && cd util Import Chicago Taxi Trips data: cd ./util-notebook/kmeans/ && psql -h 127.0.0.1 -p 5432 -U postgres -f ./import-data_chicago_taxi_trips.sql This will also create a new database called chicago_taxi_trips . Then, create a new table chicago_taxi_trips_change for the data training: -- connect to the local vidardb psql -h 127.0.0.1 -p 5432 -U postgres -- connect to the database \\c chicago_taxi_trips postgres; -- create new table DROP TABLE IF EXISTS chicago_taxi_trips_change; -- double precision array for (pickup_latitude,pickup_longitude) CREATE TABLE chicago_taxi_trips_change ( row_id SERIAL, taxi_id INT, pickup_latitude DECIMAL(10, 2), pickup_longitude DECIMAL(10, 2), row_vec DOUBLE PRECISION[] ); -- insert data INSERT INTO chicago_taxi_trips_change (taxi_id,pickup_latitude,pickup_longitude, row_vec) SELECT taxi_id, pickup_latitude, pickup_longitude, array_cat(array[pickup_latitude], array[pickup_longitude]) FROM chicago_taxi_trips; Now, the preparation is done. Let's move to the training part.","title":"Preparation"},{"location":"run_kmeans_with_vidarDB/#data-training","text":"This section is very simple and straightforward. Before training data, we need to enable AI support in chicago_taxi_trips database: docker exec -it vidardb sh -c \"install-madlib.sh -U postgres -D chicago_taxi_trips\" Try the following SQL commands to train data with KMeans: -- connect to the local vidardb psql -h 127.0.0.1 -p 5432 -U postgres -- connect to the database \\c chicago_taxi_trips postgres; -- create new table DROP TABLE IF EXISTS km_result; -- run kmeans algorithm CREATE TABLE km_result AS SELECT * FROM madlib.kmeanspp( 'chicago_taxi_trips_change', -- Table of source data 'row_vec', -- Column containing point co-ordinates 5, -- Number of centroids to calculate 'madlib.squared_dist_norm2', -- Distance function 'madlib.avg', -- Aggregate function 20, -- Number of iterations 0.001 -- Fraction of centroids reassigned to keep iterating );","title":"Data Training"},{"location":"run_kmeans_with_vidarDB/#perform-clustering-predictions","text":"Predict the cluster_id of each trip with the model we have just trained: SELECT trips_data.*, (madlib.closest_column(centroids, row_vec)).column_id AS cluster_id FROM chicago_taxi_trips_change AS trips_data, km_result ORDER BY trips_data.row_id DESC LIMIT 10; We can get some results like this: row_id | taxi_id | pickup_latitude | pickup_longitude | row_vec | cluster_id --------+---------+-----------------+------------------+------------------------------+------------ 999 | 7040 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 998 | 7145 | 41.88 | -87.64 | {41.879255084,-87.642648998} | 1 997 | 7864 | 41.79 | -87.75 | {41.785998518,-87.750934289} | 3 996 | 6620 | 41.90 | -87.62 | {41.89503345,-87.619710672} | 0 995 | 393 | 41.89 | -87.63 | {41.892072635,-87.628874157} | 0 994 | 1082 | 41.89 | -87.62 | {41.890922026,-87.618868355} | 0 993 | 55 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 992 | 7749 | 41.89 | -87.63 | {41.892042136,-87.63186395} | 0 991 | 7564 | 41.88 | -87.62 | {41.884987192,-87.620992913} | 0 990 | 7065 | 41.89 | -87.63 | {41.892507781,-87.626214906} | 0","title":"Perform Clustering Predictions"},{"location":"run_kmeans_with_vidarDB/#reference","text":"The data this example used come from Taxi Trips | City of Chicago | Data Portal . (More examples will come soon!)","title":"Reference"},{"location":"run_vidarDB_with_docker/","text":"Run VidarDB with Docker We can easily deploy VidarDB with Docker. This section will guide you to install and play with VidarDB in one minute. Requirement Docker is the only requirement. Install it at https://docs.docker.com/install/ . Run a VidarDB's Docker container Before running any of the following commands, please ensure that both the container name vidardb and the port 5432 have not been used in your environment. To run a VidarDB's Docker container: docker run -d --name vidardb -p 5432:5432 vidardb/vidardb:latest After doing that, a vidardb container will start and the database will be initialized. Connect to the VidarDB For the users who don't have the PostgreSQL client installed: docker exec -it vidardb sh -c 'psql -h 127.0.0.1 -p 5432 -U postgres' For the others who have the PostgreSQL client installed: psql -h 127.0.0.1 -p 5432 -U postgres Build your own Docker image You may want to create your custom Docker image. Do it by '1-click' in the root directory of vidardb repository: # Build a Docker image with the default name 'vidardb/vidardb:latest' make docker-image Some available build parameters: REGISTRY=<YOUR REGISTRY ADDRESS> IMAGE=<YOUR IMAGE NAME> TAG=<YOUR IMAGE TAG> make docker-image Enable AI support in your database VidarDB loves AI! Our bulit-in database has already installed MADlib which supports big data machine learning in SQL. If you want to use it in the vidardb container, try the following command: docker exec -it vidardb sh -c \"install-madlib.sh -U <YOUR DATABASE USERNAME> -P <YOUR DATABASE PASSWORD> -D <YOUR DATABASE NAME>\" For example, if you have created a new database named madlib , and the username is madlib and there is no password, then you can simply install madlib like this: docker exec -it vidardb sh -c \"install-madlib.sh -U madlib -D madlib\"","title":"Run VidarDB with Docker"},{"location":"run_vidarDB_with_docker/#run-vidardb-with-docker","text":"We can easily deploy VidarDB with Docker. This section will guide you to install and play with VidarDB in one minute.","title":"Run VidarDB with Docker"},{"location":"run_vidarDB_with_docker/#requirement","text":"Docker is the only requirement. Install it at https://docs.docker.com/install/ .","title":"Requirement"},{"location":"run_vidarDB_with_docker/#run-a-vidardbs-docker-container","text":"Before running any of the following commands, please ensure that both the container name vidardb and the port 5432 have not been used in your environment. To run a VidarDB's Docker container: docker run -d --name vidardb -p 5432:5432 vidardb/vidardb:latest After doing that, a vidardb container will start and the database will be initialized.","title":"Run a VidarDB's Docker container"},{"location":"run_vidarDB_with_docker/#connect-to-the-vidardb","text":"For the users who don't have the PostgreSQL client installed: docker exec -it vidardb sh -c 'psql -h 127.0.0.1 -p 5432 -U postgres' For the others who have the PostgreSQL client installed: psql -h 127.0.0.1 -p 5432 -U postgres","title":"Connect to the VidarDB"},{"location":"run_vidarDB_with_docker/#build-your-own-docker-image","text":"You may want to create your custom Docker image. Do it by '1-click' in the root directory of vidardb repository: # Build a Docker image with the default name 'vidardb/vidardb:latest' make docker-image Some available build parameters: REGISTRY=<YOUR REGISTRY ADDRESS> IMAGE=<YOUR IMAGE NAME> TAG=<YOUR IMAGE TAG> make docker-image","title":"Build your own Docker image"},{"location":"run_vidarDB_with_docker/#enable-ai-support-in-your-database","text":"VidarDB loves AI! Our bulit-in database has already installed MADlib which supports big data machine learning in SQL. If you want to use it in the vidardb container, try the following command: docker exec -it vidardb sh -c \"install-madlib.sh -U <YOUR DATABASE USERNAME> -P <YOUR DATABASE PASSWORD> -D <YOUR DATABASE NAME>\" For example, if you have created a new database named madlib , and the username is madlib and there is no password, then you can simply install madlib like this: docker exec -it vidardb sh -c \"install-madlib.sh -U madlib -D madlib\"","title":"Enable AI support in your database"},{"location":"what_is_vidarDB/","text":"What is VidarDB Welcome to this section, where you will get an overview of VidarDB. Basic Info VidarDB is a unified database system for simplifying companies' architecture in the data layer, with the same interface as PostgreSQL and 50~1000X speedup. It can replace multiple data tools (Message Queues, Server Caches, Operational Databases, Data warehouse, Machine Learning) with a single unified tool, due to its efficiency, and is designed to break the trade-off between simplicity (general databases) and efficiency (purpose-built databases). Target Problem Typically, companies have to install two groups of tools: one optimized for interactive client operations (e.g., message queue, server cache, operational database), and another for business analysis (e.g., data warehouse and machine learning). This deployment approach has two major drawbacks: First, it is time-consuming and costly, as multiple systems need to be maintained by expert administrators. Second, as the data need to be migrated between the different tools, it effects data freshness and reduces its business value. VidarDB is the unified database system that eliminates the need for installing and maintaining multiple data processing tools, which significantly reduces companies' software costs and human capital, and at the same time it enables the real-time reporting. Core Tech Unlike any other database that almost relies on the data structure designed in the 1970s, VidarDB is built on a new data structure we designed for modern memory architecture, efficiently supporting RAM, NVM, SSD, Disk as well as smooth data flow among these storage tiers. Additionally, it is a versatile data structure, which will adapt to and optimize for different workloads, such as operational, data analysis, streaming and even mixed of them. Then, we have brought the machine learning ability into VidarDB, where users can run familiar machine learning algorithms inside VidarDB via SQL, without moving your data to other tools. VidarDB has a novel storage engine built on our designed data structure, and an additional layer to support machine learning. At the same time, it utilizes many PostgreSQL components such as parser and optimizer, and with the same interface.","title":"What is VidarDB"},{"location":"what_is_vidarDB/#what-is-vidardb","text":"Welcome to this section, where you will get an overview of VidarDB.","title":"What is VidarDB"},{"location":"what_is_vidarDB/#basic-info","text":"VidarDB is a unified database system for simplifying companies' architecture in the data layer, with the same interface as PostgreSQL and 50~1000X speedup. It can replace multiple data tools (Message Queues, Server Caches, Operational Databases, Data warehouse, Machine Learning) with a single unified tool, due to its efficiency, and is designed to break the trade-off between simplicity (general databases) and efficiency (purpose-built databases).","title":"Basic Info"},{"location":"what_is_vidarDB/#target-problem","text":"Typically, companies have to install two groups of tools: one optimized for interactive client operations (e.g., message queue, server cache, operational database), and another for business analysis (e.g., data warehouse and machine learning). This deployment approach has two major drawbacks: First, it is time-consuming and costly, as multiple systems need to be maintained by expert administrators. Second, as the data need to be migrated between the different tools, it effects data freshness and reduces its business value. VidarDB is the unified database system that eliminates the need for installing and maintaining multiple data processing tools, which significantly reduces companies' software costs and human capital, and at the same time it enables the real-time reporting.","title":"Target Problem"},{"location":"what_is_vidarDB/#core-tech","text":"Unlike any other database that almost relies on the data structure designed in the 1970s, VidarDB is built on a new data structure we designed for modern memory architecture, efficiently supporting RAM, NVM, SSD, Disk as well as smooth data flow among these storage tiers. Additionally, it is a versatile data structure, which will adapt to and optimize for different workloads, such as operational, data analysis, streaming and even mixed of them. Then, we have brought the machine learning ability into VidarDB, where users can run familiar machine learning algorithms inside VidarDB via SQL, without moving your data to other tools. VidarDB has a novel storage engine built on our designed data structure, and an additional layer to support machine learning. At the same time, it utilizes many PostgreSQL components such as parser and optimizer, and with the same interface.","title":"Core Tech"}]}