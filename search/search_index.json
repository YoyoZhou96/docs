{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to VidarDB VidarDB is actively developed and maintained by VidarDB Team. It is built on RocksDB and earlier work on LevelDB by Sanjay Ghemawat (sanjay@google.com) and Jeff Dean (jeff@google.com).","title":"Welcome to VidarDB"},{"location":"#welcome-to-vidardb","text":"VidarDB is actively developed and maintained by VidarDB Team. It is built on RocksDB and earlier work on LevelDB by Sanjay Ghemawat (sanjay@google.com) and Jeff Dean (jeff@google.com).","title":"Welcome to VidarDB"},{"location":"example/","text":"VidarDB Examples In this section, we are going to show some VidarDB fundamental commands and basic interactions with Postgresql. Fundamental Commands To create a database example and change to use it: CREATE DATABASE example; \\c example; Create a new table student using VidarDB's data engine: CREATE EXTENSION kv_fdw; CREATE SERVER kv_server FOREIGN DATA WRAPPER kv_fdw; CREATE FOREIGN TABLE student(name TEXT, ID TEXT) SERVER kv_server; Let's try to insert some fresh data into our new table: INSERT INTO student VALUES('Rafferty', '20757123'); INSERT INTO student VALUES('Jones', '20767234'); INSERT INTO student VALUES('Heisenberg', '20777345'); In the next step, use SELECT statment to query students' information: example=# SELECT * FROM student; name | id ------------+---------- Jones | 20767234 Rafferty | 20757123 Heisenberg | 20777345 (3 rows) Also have a try at DELETE statment: example=# DELETE FROM student WHERE NAME='Jones'; DELETE 1 example=# SELECT * FROM student; name | id ------------+---------- Rafferty | 20757123 Heisenberg | 20777345 (2 rows) And update Rafferty's student id to 20757321 : example=# UPDATE student SET ID='20757321' WHERE NAME='Rafferty'; UPDATE 1 example=# SELECT * FROM student; name | id ------------+---------- Rafferty | 20757321 Heisenberg | 20777345 (2 rows) Interaction with Postgresql VidarDB works well with the original Postgresql. Now, we will create another new table using Postgresql's data engine and add one row into it: CREATE TABLE student_course(ID TEXT, COURSE TEXT); INSERT INTO student_course VALUES('20757321', 'Computer Science'); We currently have something like: example=# SELECT * FROM student_course; id | course ----------+------------------ 20757321 | Computer Science (1 row) Let's try with the INNER JOIN with the table student (created using VidarDB) and student_course (created by Postgresql): example=# SELECT student.name FROM student INNER JOIN student_course ON student.id = student_course.id; name ---------- Rafferty (1 row) (More examples will come soon!)","title":"VidarDB Examples"},{"location":"example/#vidardb-examples","text":"In this section, we are going to show some VidarDB fundamental commands and basic interactions with Postgresql.","title":"VidarDB Examples"},{"location":"example/#fundamental-commands","text":"To create a database example and change to use it: CREATE DATABASE example; \\c example; Create a new table student using VidarDB's data engine: CREATE EXTENSION kv_fdw; CREATE SERVER kv_server FOREIGN DATA WRAPPER kv_fdw; CREATE FOREIGN TABLE student(name TEXT, ID TEXT) SERVER kv_server; Let's try to insert some fresh data into our new table: INSERT INTO student VALUES('Rafferty', '20757123'); INSERT INTO student VALUES('Jones', '20767234'); INSERT INTO student VALUES('Heisenberg', '20777345'); In the next step, use SELECT statment to query students' information: example=# SELECT * FROM student; name | id ------------+---------- Jones | 20767234 Rafferty | 20757123 Heisenberg | 20777345 (3 rows) Also have a try at DELETE statment: example=# DELETE FROM student WHERE NAME='Jones'; DELETE 1 example=# SELECT * FROM student; name | id ------------+---------- Rafferty | 20757123 Heisenberg | 20777345 (2 rows) And update Rafferty's student id to 20757321 : example=# UPDATE student SET ID='20757321' WHERE NAME='Rafferty'; UPDATE 1 example=# SELECT * FROM student; name | id ------------+---------- Rafferty | 20757321 Heisenberg | 20777345 (2 rows)","title":"Fundamental Commands"},{"location":"example/#interaction-with-postgresql","text":"VidarDB works well with the original Postgresql. Now, we will create another new table using Postgresql's data engine and add one row into it: CREATE TABLE student_course(ID TEXT, COURSE TEXT); INSERT INTO student_course VALUES('20757321', 'Computer Science'); We currently have something like: example=# SELECT * FROM student_course; id | course ----------+------------------ 20757321 | Computer Science (1 row) Let's try with the INNER JOIN with the table student (created using VidarDB) and student_course (created by Postgresql): example=# SELECT student.name FROM student INNER JOIN student_course ON student.id = student_course.id; name ---------- Rafferty (1 row) (More examples will come soon!)","title":"Interaction with Postgresql"},{"location":"faq/","text":"Frequently Asked Questions How is VidarDB different from other traditional database systems? The core data structures in traditional database systems like B+ trees were invented in the 1970s. They are optimized for the old storage medium. In contrast, VidarDB is designed for modern fast storage. VidarDB is based on the log-structured merge tree (LSM Tree) data structure that has the following advantages: superior write performance: inserts and updates are only appended to the top level of the tree, so the LSM Tree requires only sequential writes and avoids random writes. eventual merge down the hierarchy: read performance and space utilization are improved while the cost of compaction and obsolete data cleaning is amortized. a data structure of data structures: A LSM tree maintains data in two or more separate levels, each of which is optimized for its respective underlying storage medium. Each level can have its own data structure. The memory component can use a skip list or a B+ tree while the disk component can use a B+ tree or a sorted string table (SSTable). VidarDB is the world\u2019s first system that introduces the column store into the LSM-tree. This innovation brings an amazing speedup for analytical workloads. The fundamental advantage in the core data structure makes VidarDB a powerful engine for business intelligence. In addtion, thanks to the MADlib library, VidarDB can support AI algorithms in SQL. What is the relationship between VidarDB and Postgresql? Postgresql is one of the most popular and advanced open source database systems. Currently VidarDB is used as a storage engine of Postgresql. Compared to the original Postgresql, VidarDB provides a significant improvement in performance. Meanwhile, VidarDB embraces the PostgreSQL ecosystem. All the client drivers, tools and other components in Postgresql like its outstanding parser and optimizer can be reused by VidarDB. Is VidarDB stable enough to use? VidarDB is not developed from scratch. Instead, VidarDB is built on the mature key-value store - RocksDB. VidarDB improves the core data structure and keeps the quality of codes. What are the system requirements for VidarDB? VidarDB is written in C++ and the native server runs on Linux systems. Other operating systems are being tested. We also provide a docker image for users to quickly deploy VidarDB on any platform. What client driver can I use to work with VidarDB? VidarDB reuses the frontend of Postgresql, so the client drivers for Postgresql can also work with VidarDB. Languages such as Java, C++, Python and C#/.Net are all supported. Does VidarDB support SQL? Yes, VidarDB supports the SQL syntax in Postgresql. Users can even write their AI algorithms using SQL. Does VidarDB support atomic operations? Yes, all the operations in VidarDB are atomic, but VidarDB does not support full ACID for now. How is VidarDB licensed? VidarDB is licensed under the BSD 3-Clause Clear License.","title":"Frequently Asked Questions"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently Asked Questions"},{"location":"faq/#how-is-vidardb-different-from-other-traditional-database-systems","text":"The core data structures in traditional database systems like B+ trees were invented in the 1970s. They are optimized for the old storage medium. In contrast, VidarDB is designed for modern fast storage. VidarDB is based on the log-structured merge tree (LSM Tree) data structure that has the following advantages: superior write performance: inserts and updates are only appended to the top level of the tree, so the LSM Tree requires only sequential writes and avoids random writes. eventual merge down the hierarchy: read performance and space utilization are improved while the cost of compaction and obsolete data cleaning is amortized. a data structure of data structures: A LSM tree maintains data in two or more separate levels, each of which is optimized for its respective underlying storage medium. Each level can have its own data structure. The memory component can use a skip list or a B+ tree while the disk component can use a B+ tree or a sorted string table (SSTable). VidarDB is the world\u2019s first system that introduces the column store into the LSM-tree. This innovation brings an amazing speedup for analytical workloads. The fundamental advantage in the core data structure makes VidarDB a powerful engine for business intelligence. In addtion, thanks to the MADlib library, VidarDB can support AI algorithms in SQL.","title":"How is VidarDB different from other traditional database systems?"},{"location":"faq/#what-is-the-relationship-between-vidardb-and-postgresql","text":"Postgresql is one of the most popular and advanced open source database systems. Currently VidarDB is used as a storage engine of Postgresql. Compared to the original Postgresql, VidarDB provides a significant improvement in performance. Meanwhile, VidarDB embraces the PostgreSQL ecosystem. All the client drivers, tools and other components in Postgresql like its outstanding parser and optimizer can be reused by VidarDB.","title":"What is the relationship between VidarDB and Postgresql?"},{"location":"faq/#is-vidardb-stable-enough-to-use","text":"VidarDB is not developed from scratch. Instead, VidarDB is built on the mature key-value store - RocksDB. VidarDB improves the core data structure and keeps the quality of codes.","title":"Is VidarDB stable enough to use?"},{"location":"faq/#what-are-the-system-requirements-for-vidardb","text":"VidarDB is written in C++ and the native server runs on Linux systems. Other operating systems are being tested. We also provide a docker image for users to quickly deploy VidarDB on any platform.","title":"What are the system requirements for VidarDB?"},{"location":"faq/#what-client-driver-can-i-use-to-work-with-vidardb","text":"VidarDB reuses the frontend of Postgresql, so the client drivers for Postgresql can also work with VidarDB. Languages such as Java, C++, Python and C#/.Net are all supported.","title":"What client driver can I use to work with VidarDB?"},{"location":"faq/#does-vidardb-support-sql","text":"Yes, VidarDB supports the SQL syntax in Postgresql. Users can even write their AI algorithms using SQL.","title":"Does VidarDB support SQL?"},{"location":"faq/#does-vidardb-support-atomic-operations","text":"Yes, all the operations in VidarDB are atomic, but VidarDB does not support full ACID for now.","title":"Does VidarDB support atomic operations?"},{"location":"faq/#how-is-vidardb-licensed","text":"VidarDB is licensed under the BSD 3-Clause Clear License.","title":"How is VidarDB licensed?"},{"location":"run_kmeans_with_vidarDB/","text":"Run KMeans with VidarDB VidarDB has a native support to MADlib , which allowed you to perfrom many commonly used algorithms in SQL easily. This page gives you a good example of using KMeans clustering algorithm provided by MADlib to train your data in VidarDB. It assumes you already have VidarDB installed. If you do not, head over to the Run VidarDB in Docker section. Preparation Clone and go into the VidarDB's util repository: git clone https://github.com/vidardb/util.git && cd util Import Chicago Taxi Tips data (If you don't have psql client installed, install it beforing executing the following command): cd ./util-notebook/kmeans/ && psql -U postgres -W -f ./import-data_chicago_taxi_trips.sql This command will also create a new database called chicago_taxi_trips . Then, we create a new table chicago_taxi_trips_change for the data training: insert into chicago_taxi_trips_change (taxi_id,pickup_latitude,pickup_longitude, row_vec) select taxi_id, pickup_latitude, pickup_longitude, array_cat(array[pickup_latitude], array[pickup_longitude]) from chicago_taxi_trips Now, the preparation job is done. Let's move to the training part. Data Training This section is very simple and straightforward. Try the following SQL commands to use KMeans algorithm to train the data: DROP TABLE IF EXISTS km_result; -- Run kmeans algorithm CREATE TABLE km_result AS SELECT * FROM madlib.kmeanspp( 'chicago_taxi_trips_change', -- Table of source data 'row_vec', -- Column containing point co-ordinates 5, -- Number of centroids to calculate 'madlib.squared_dist_norm2', -- Distance function 'madlib.avg', -- Aggregate function 20, -- Number of iterations 0.001 -- Fraction of centroids reassigned to keep iterating ); Perform Clustering Predictions Use the model we trained to predict the cluster_id of each trip: SELECT trips_data.*, (madlib.closest_column(centroids, row_vec)).column_id AS cluster_id FROM chicago_taxi_trips_change AS trips_data, km_result ORDER BY trips_data.row_id DESC LIMIT 10; We get some results like this: row_id | taxi_id | pickup_latitude | pickup_longitude | row_vec | cluster_id --------+---------+-----------------+------------------+------------------------------+------------ 999 | 7040 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 998 | 7145 | 41.88 | -87.64 | {41.879255084,-87.642648998} | 1 997 | 7864 | 41.79 | -87.75 | {41.785998518,-87.750934289} | 3 996 | 6620 | 41.90 | -87.62 | {41.89503345,-87.619710672} | 0 995 | 393 | 41.89 | -87.63 | {41.892072635,-87.628874157} | 0 994 | 1082 | 41.89 | -87.62 | {41.890922026,-87.618868355} | 0 993 | 55 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 992 | 7749 | 41.89 | -87.63 | {41.892042136,-87.63186395} | 0 991 | 7564 | 41.88 | -87.62 | {41.884987192,-87.620992913} | 0 990 | 7065 | 41.89 | -87.63 | {41.892507781,-87.626214906} | 0 Reference The data this example used come from Taxi Trips | City of Chicago | Data Portal .","title":"Run KMeans with VidarDB"},{"location":"run_kmeans_with_vidarDB/#run-kmeans-with-vidardb","text":"VidarDB has a native support to MADlib , which allowed you to perfrom many commonly used algorithms in SQL easily. This page gives you a good example of using KMeans clustering algorithm provided by MADlib to train your data in VidarDB. It assumes you already have VidarDB installed. If you do not, head over to the Run VidarDB in Docker section.","title":"Run KMeans with VidarDB"},{"location":"run_kmeans_with_vidarDB/#preparation","text":"Clone and go into the VidarDB's util repository: git clone https://github.com/vidardb/util.git && cd util Import Chicago Taxi Tips data (If you don't have psql client installed, install it beforing executing the following command): cd ./util-notebook/kmeans/ && psql -U postgres -W -f ./import-data_chicago_taxi_trips.sql This command will also create a new database called chicago_taxi_trips . Then, we create a new table chicago_taxi_trips_change for the data training: insert into chicago_taxi_trips_change (taxi_id,pickup_latitude,pickup_longitude, row_vec) select taxi_id, pickup_latitude, pickup_longitude, array_cat(array[pickup_latitude], array[pickup_longitude]) from chicago_taxi_trips Now, the preparation job is done. Let's move to the training part.","title":"Preparation"},{"location":"run_kmeans_with_vidarDB/#data-training","text":"This section is very simple and straightforward. Try the following SQL commands to use KMeans algorithm to train the data: DROP TABLE IF EXISTS km_result; -- Run kmeans algorithm CREATE TABLE km_result AS SELECT * FROM madlib.kmeanspp( 'chicago_taxi_trips_change', -- Table of source data 'row_vec', -- Column containing point co-ordinates 5, -- Number of centroids to calculate 'madlib.squared_dist_norm2', -- Distance function 'madlib.avg', -- Aggregate function 20, -- Number of iterations 0.001 -- Fraction of centroids reassigned to keep iterating );","title":"Data Training"},{"location":"run_kmeans_with_vidarDB/#perform-clustering-predictions","text":"Use the model we trained to predict the cluster_id of each trip: SELECT trips_data.*, (madlib.closest_column(centroids, row_vec)).column_id AS cluster_id FROM chicago_taxi_trips_change AS trips_data, km_result ORDER BY trips_data.row_id DESC LIMIT 10; We get some results like this: row_id | taxi_id | pickup_latitude | pickup_longitude | row_vec | cluster_id --------+---------+-----------------+------------------+------------------------------+------------ 999 | 7040 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 998 | 7145 | 41.88 | -87.64 | {41.879255084,-87.642648998} | 1 997 | 7864 | 41.79 | -87.75 | {41.785998518,-87.750934289} | 3 996 | 6620 | 41.90 | -87.62 | {41.89503345,-87.619710672} | 0 995 | 393 | 41.89 | -87.63 | {41.892072635,-87.628874157} | 0 994 | 1082 | 41.89 | -87.62 | {41.890922026,-87.618868355} | 0 993 | 55 | 41.88 | -87.63 | {41.880994471,-87.632746489} | 1 992 | 7749 | 41.89 | -87.63 | {41.892042136,-87.63186395} | 0 991 | 7564 | 41.88 | -87.62 | {41.884987192,-87.620992913} | 0 990 | 7065 | 41.89 | -87.63 | {41.892507781,-87.626214906} | 0","title":"Perform Clustering Predictions"},{"location":"run_kmeans_with_vidarDB/#reference","text":"The data this example used come from Taxi Trips | City of Chicago | Data Portal .","title":"Reference"},{"location":"run_vidarDB_in_docker/","text":"Run VidarDB in Docker We can easily deploy PostgreSQL with VidarDB in a Docker container. The following document will guide you to install and play with VidarDB in one minute. Requirement Docker is the only requirement. Install it at https://docs.docker.com/install/ . Run a VidarDB's Docker container Before running any of the following commands, please ensure that both the container name postgresql and the port 5432 have not been used in your environment. To run a VidarDB's Docker container: docker run -d --name postgresql -p 5432:5432 vidardb/postgresql:vidardb-latest After doing that, a postgresql container will start and the database will be initialized. Connect to the PostgreSQL psql -h 127.0.0.1 -p 5432 -U postgres A welcome from the PostgreSQL should appear. Please note that the PostgreSQL client should already be installed before running the container. For the users who don't have the PostgreSQL client installed: docker exec -it postgresql /bin/bash Then we can connect to the PostgreSQL successfully inside the container (retry the connecting command again). Building your own Docker image You may want to create your custom Docker image. Do it by '1-click': # Building a Docker image with the default name 'vidardb/postgresql:vidardb-latest' make docker-image Some available build parameters: REGISTRY=<YOUR REGISTRY ADDRESS> IMAGE=<YOUR IMAGE NAME> TAG=<YOUR IMAGE TAG> make docker-image Enable AI support in your database VidarDB loves AI! Our bulit-in database has already installed MADlib which supports big data machine learning in SQL. If you want to use it in the postgresql container, try the following command: docker exec -it postgresql sh -c \"install-madlib.sh -U <YOUR DATABASE USERNAME> -P <YOUR DATABASE PASSWORD> -D <YOUR DATABASE NAME>\" For example, if you have created a new database named madlib , and the username is madlib and there is no password, then you can simply install madlib like this: docker exec -it postgresql sh -c \"install-madlib.sh -U madlib -D madlib\"","title":"Run VidarDB in Docker"},{"location":"run_vidarDB_in_docker/#run-vidardb-in-docker","text":"We can easily deploy PostgreSQL with VidarDB in a Docker container. The following document will guide you to install and play with VidarDB in one minute.","title":"Run VidarDB in Docker"},{"location":"run_vidarDB_in_docker/#requirement","text":"Docker is the only requirement. Install it at https://docs.docker.com/install/ .","title":"Requirement"},{"location":"run_vidarDB_in_docker/#run-a-vidardbs-docker-container","text":"Before running any of the following commands, please ensure that both the container name postgresql and the port 5432 have not been used in your environment. To run a VidarDB's Docker container: docker run -d --name postgresql -p 5432:5432 vidardb/postgresql:vidardb-latest After doing that, a postgresql container will start and the database will be initialized.","title":"Run a VidarDB's Docker container"},{"location":"run_vidarDB_in_docker/#connect-to-the-postgresql","text":"psql -h 127.0.0.1 -p 5432 -U postgres A welcome from the PostgreSQL should appear. Please note that the PostgreSQL client should already be installed before running the container. For the users who don't have the PostgreSQL client installed: docker exec -it postgresql /bin/bash Then we can connect to the PostgreSQL successfully inside the container (retry the connecting command again).","title":"Connect to the PostgreSQL"},{"location":"run_vidarDB_in_docker/#building-your-own-docker-image","text":"You may want to create your custom Docker image. Do it by '1-click': # Building a Docker image with the default name 'vidardb/postgresql:vidardb-latest' make docker-image Some available build parameters: REGISTRY=<YOUR REGISTRY ADDRESS> IMAGE=<YOUR IMAGE NAME> TAG=<YOUR IMAGE TAG> make docker-image","title":"Building your own Docker image"},{"location":"run_vidarDB_in_docker/#enable-ai-support-in-your-database","text":"VidarDB loves AI! Our bulit-in database has already installed MADlib which supports big data machine learning in SQL. If you want to use it in the postgresql container, try the following command: docker exec -it postgresql sh -c \"install-madlib.sh -U <YOUR DATABASE USERNAME> -P <YOUR DATABASE PASSWORD> -D <YOUR DATABASE NAME>\" For example, if you have created a new database named madlib , and the username is madlib and there is no password, then you can simply install madlib like this: docker exec -it postgresql sh -c \"install-madlib.sh -U madlib -D madlib\"","title":"Enable AI support in your database"}]}